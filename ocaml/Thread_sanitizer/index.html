<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Thread_sanitizer (ocaml.Thread_sanitizer)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ocaml</a> &#x00BB; Thread_sanitizer</nav><header class="odoc-preamble"><h1>Module <code><span>Thread_sanitizer</span></code></h1><p>Instrumentation of memory accesses to use ThreadSanitizer (TSan) for data race detection. This module contains an instrumentation pass on Cmm, where most of the instrumentation happens.</p><p>TSan requires to instrument all memory accesses (to mutable data), thread spawning and joining, mutex operations, and all such events that are relevant for parallelism. Thread and mutex operations are instrumented by the C compiler via the runtime. Instrumentation calls are FFI (C) calls.</p><p>TSan also requires to instrument the entry and exit of each function. TSan records function entries and exits along with other events in a history in to be able to print backtraces of an event (memory access, mutex creation...) when needed.</p><p>In addition to this static instrumentation, we must let TSan know when a function is exited due to an exception or when performing effect, or re-entered when resuming a continuation. This dynamic instrumentation is performed by dedicated runtime functions in runtime/tsan.c. These functions are called from the assembly chunks of the runtime.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-instrument"><a href="#val-instrument" class="anchor"></a><code><span><span class="keyword">val</span> instrument : <span><a href="../Cmm/index.html#type-expression">Cmm.expression</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Cmm/index.html#type-expression">Cmm.expression</a></span></code></div><div class="spec-doc"><p>Instrumentation of a <a href="../Cmm/index.html#type-expression"><code>Cmm.expression</code></a>: instrument memory accesses, and surround the expression by external calls to <code>__tsan_func_entry</code> and <code>__tsan_func_exit</code>. If the expression tail is a function call, then <code>__tsan_func_exit</code> is inserted before that call.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wrap_entry_exit"><a href="#val-wrap_entry_exit" class="anchor"></a><code><span><span class="keyword">val</span> wrap_entry_exit : <span><a href="../Cmm/index.html#type-expression">Cmm.expression</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Cmm/index.html#type-expression">Cmm.expression</a></span></code></div><div class="spec-doc"><p>Surround an expression by external calls to <code>__tsan_func_entry</code> and <code>__tsan_func_exit</code>. If the expression tail is a function call, then <code>__tsan_func_exit</code> is inserted before that call.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_code"><a href="#val-init_code" class="anchor"></a><code><span><span class="keyword">val</span> init_code : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="../Cmm/index.html#type-expression">Cmm.expression</a></span></code></div><div class="spec-doc"><p>Call to <code>__tsan_init</code>, which should be called at least once in the compiled program, before other <code>__tsan_*</code> API functions. <code>__tsan_init</code> is idempotent, i.e. can be called more than once without consequences.</p></div></div></div></body></html>
