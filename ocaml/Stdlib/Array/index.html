<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Array (ocaml.Stdlib.Array)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ocaml</a> &#x00BB; <a href="../index.html">Stdlib</a> &#x00BB; Array</nav><header class="odoc-preamble"><h1>Module <code><span>Stdlib.Array</span></code></h1><p>Array operations.</p><p>The labeled version of this module can be used as described in the <a href="../StdLabels/index.html"><code>StdLabels</code></a> module.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#iterators">Iterators</a></li><li><a href="#iterators-on-two-arrays">Iterators on two arrays</a></li><li><a href="#array-scanning">Array scanning</a></li><li><a href="#arrays-of-pairs">Arrays of pairs</a></li><li><a href="#sorting_and_shuffling">Sorting and shuffling</a></li><li><a href="#arrays-and-sequences">Arrays and Sequences</a></li><li><a href="#array_concurrency">Arrays and concurrency safety</a><ul><li><a href="#array_atomicity">Atomicity</a></li><li><a href="#array_data_race">Data races</a></li><li><a href="#array_data_race_exceptions">Float arrays</a></li></ul></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p>An alias for the type of arrays.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the length (number of elements) of the given array.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get a n</code> returns the element number <code>n</code> of array <code>a</code>. The first element has number 0. The last element has number <code>length a - 1</code>. You can also write <code>a.(n)</code> instead of <code>get a n</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>n</code> is outside the range 0 to <code>(length a - 1)</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set a n x</code> modifies array <code>a</code> in place, replacing element number <code>n</code> with <code>x</code>. You can also write <code>a.(n) &lt;- x</code> instead of <code>set a n x</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>n</code> is outside the range 0 to <code>length a - 1</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p><code>make n x</code> returns a fresh array of length <code>n</code>, initialized with <code>x</code>. All the elements of this new array are initially physically equal to <code>x</code> (in the sense of the <code>==</code> predicate). Consequently, if <code>x</code> is mutable, it is shared among all elements of the array, and modifying <code>x</code> through one of the array entries will modify all other entries at the same time.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the value of <code>x</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-create_float"><a href="#val-create_float" class="anchor"></a><code><span><span class="keyword">val</span> create_float : <span>int <span class="arrow">&#45;&gt;</span></span> <span>float array</span></span></code></div><div class="spec-doc"><p><code>create_float n</code> returns a fresh float array of length <code>n</code>, with uninitialized data.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init"><a href="#val-init" class="anchor"></a><code><span><span class="keyword">val</span> init : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p><code>init n f</code> returns a fresh array of length <code>n</code>, with element number <code>i</code> initialized to the result of <code>f i</code>. In other terms, <code>init n f</code> tabulates the results of <code>f</code> applied in order to the integers <code>0</code> to <code>n-1</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>n &lt; 0</code> or <code>n &gt; Sys.max_array_length</code>. If the return type of <code>f</code> is <code>float</code>, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_matrix"><a href="#val-make_matrix" class="anchor"></a><code><span><span class="keyword">val</span> make_matrix : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> array</span></span></code></div><div class="spec-doc"><p><code>make_matrix dimx dimy e</code> returns a two-dimensional array (an array of arrays) with first dimension <code>dimx</code> and second dimension <code>dimy</code>. All the elements of this new matrix are initially physically equal to <code>e</code>. The element (<code>x,y</code>) of a matrix <code>m</code> is accessed with the notation <code>m.(x).(y)</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>dimx</code> or <code>dimy</code> is negative or greater than <a href="../Sys/index.html#val-max_array_length"><code>Sys.max_array_length</code></a>. If the value of <code>e</code> is a floating-point number, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-init_matrix"><a href="#val-init_matrix" class="anchor"></a><code><span><span class="keyword">val</span> init_matrix : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> array</span></span></code></div><div class="spec-doc"><p><code>init_matrix dimx dimy f</code> returns a two-dimensional array (an array of arrays) with first dimension <code>dimx</code> and second dimension <code>dimy</code>, where the element at index (<code>x,y</code>) is initialized with <code>f x y</code>. The element (<code>x,y</code>) of a matrix <code>m</code> is accessed with the notation <code>m.(x).(y)</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>dimx</code> or <code>dimy</code> is negative or greater than <a href="../Sys/index.html#val-max_array_length"><code>Sys.max_array_length</code></a>. If the return type of <code>f</code> is <code>float</code>, then the maximum size is only <code>Sys.max_array_length / 2</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.2</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-append"><a href="#val-append" class="anchor"></a><code><span><span class="keyword">val</span> append : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p><code>append v1 v2</code> returns a fresh array containing the concatenation of the arrays <code>v1</code> and <code>v2</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>length v1 + length v2 &gt; Sys.max_array_length</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span><span class="keyword">val</span> concat : <span><span><span><span class="type-var">'a</span> array</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-append"><code>append</code></a>, but concatenates a list of arrays.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span><span class="keyword">val</span> sub : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p><code>sub a pos len</code> returns a fresh array of length <code>len</code>, containing the elements number <code>pos</code> to <code>pos + len - 1</code> of array <code>a</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>pos</code> and <code>len</code> do not designate a valid subarray of <code>a</code>; that is, if <code>pos &lt; 0</code>, or <code>len &lt; 0</code>, or <code>pos + len &gt; length a</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p><code>copy a</code> returns a copy of <code>a</code>, that is, a fresh array containing the same elements as <code>a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span><span class="keyword">val</span> fill : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fill a pos len x</code> modifies the array <code>a</code> in place, storing <code>x</code> in elements number <code>pos</code> to <code>pos + len - 1</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>pos</code> and <code>len</code> do not designate a valid subarray of <code>a</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span><span class="keyword">val</span> blit : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>blit src src_pos dst dst_pos len</code> copies <code>len</code> elements from array <code>src</code>, starting at element number <code>src_pos</code>, to array <code>dst</code>, starting at element number <code>dst_pos</code>. It works correctly even if <code>src</code> and <code>dst</code> are the same array, and the source and destination chunks overlap.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if <code>src_pos</code> and <code>len</code> do not designate a valid subarray of <code>src</code>, or if <code>dst_pos</code> and <code>len</code> do not designate a valid subarray of <code>dst</code>.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>to_list a</code> returns the list of all the elements of <code>a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p><code>of_list l</code> returns a fresh array containing the elements of <code>l</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if the length of <code>l</code> is greater than <code>Sys.max_array_length</code>.</p></li></ul></div></div><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f a</code> applies function <code>f</code> in turn to all the elements of <code>a</code>. It is equivalent to <code>f a.(0); f a.(1); ...; f a.(length a - 1); ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span><span class="keyword">val</span> iteri : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-iter"><code>iter</code></a>, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> array</span></span></code></div><div class="spec-doc"><p><code>map f a</code> applies function <code>f</code> to all the elements of <code>a</code>, and builds an array with the results returned by <code>f</code>: <code>[| f a.(0); f a.(1); ...; f a.(length a - 1) |]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_inplace"><a href="#val-map_inplace" class="anchor"></a><code><span><span class="keyword">val</span> map_inplace : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>map_inplace f a</code> applies function <code>f</code> to all elements of <code>a</code>, and updates their values in place.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.1</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> array</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-map"><code>map</code></a>, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi_inplace"><a href="#val-mapi_inplace" class="anchor"></a><code><span><span class="keyword">val</span> mapi_inplace : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-map_inplace"><code>map_inplace</code></a>, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.1</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span><span class="keyword">val</span> fold_left : <span><span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold_left f init a</code> computes <code>f (... (f (f init a.(0)) a.(1)) ...) a.(n-1)</code>, where <code>n</code> is the length of the array <code>a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_left_map"><a href="#val-fold_left_map" class="anchor"></a><code><span><span class="keyword">val</span> fold_left_map : 
  <span><span>(<span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span> * <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'acc</span> * <span><span class="type-var">'b</span> array</span></span></code></div><div class="spec-doc"><p><code>fold_left_map</code> is a combination of <a href="#val-fold_left"><code>fold_left</code></a> and <a href="#val-map"><code>map</code></a> that threads an accumulator through calls to <code>f</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.13</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span><span class="keyword">val</span> fold_right : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold_right f a init</code> computes <code>f a.(0) (f a.(1) ( ... (f a.(n-1) init) ...))</code>, where <code>n</code> is the length of the array <code>a</code>.</p></div></div><h2 id="iterators-on-two-arrays"><a href="#iterators-on-two-arrays" class="anchor"></a>Iterators on two arrays</h2><div class="odoc-spec"><div class="spec value anchored" id="val-iter2"><a href="#val-iter2" class="anchor"></a><code><span><span class="keyword">val</span> iter2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter2 f a b</code> applies function <code>f</code> to all the elements of <code>a</code> and <code>b</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if the arrays are not the same size.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03 (4.05 in ArrayLabels)</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span><span class="keyword">val</span> map2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> array</span></span></code></div><div class="spec-doc"><p><code>map2 f a b</code> applies function <code>f</code> to all the elements of <code>a</code> and <code>b</code>, and builds an array with the results returned by <code>f</code>: <code>[| f a.(0) b.(0); ...; f a.(length a - 1) b.(length b - 1)|]</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if the arrays are not the same size.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03 (4.05 in ArrayLabels)</li></ul></div></div><h2 id="array-scanning"><a href="#array-scanning" class="anchor"></a>Array scanning</h2><div class="odoc-spec"><div class="spec value anchored" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all f [|a1; ...; an|]</code> checks if all elements of the array satisfy the predicate <code>f</code>. That is, it returns <code>(f a1) &amp;&amp; (f a2) &amp;&amp; ... &amp;&amp; (f an)</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists"><a href="#val-exists" class="anchor"></a><code><span><span class="keyword">val</span> exists : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>exists f [|a1; ...; an|]</code> checks if at least one element of the array satisfies the predicate <code>f</code>. That is, it returns <code>(f a1) || (f a2) || ... || (f an)</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all2"><a href="#val-for_all2" class="anchor"></a><code><span><span class="keyword">val</span> for_all2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> array</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-for_all"><code>for_all</code></a>, but for a two-argument predicate.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if the two arrays have different lengths.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.11</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exists2"><a href="#val-exists2" class="anchor"></a><code><span><span class="keyword">val</span> exists2 : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> array</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-exists"><code>exists</code></a>, but for a two-argument predicate.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="../index.html#exception-Invalid_argument"><code>Invalid_argument</code></a> <p>if the two arrays have different lengths.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.11</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem a set</code> is true if and only if <code>a</code> is structurally equal to an element of <code>set</code> (i.e. there is an <code>x</code> in <code>set</code> such that <code>compare a x = 0</code>).</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memq"><a href="#val-memq" class="anchor"></a><code><span><span class="keyword">val</span> memq : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Same as <a href="#val-mem"><code>mem</code></a>, but uses physical equality instead of structural equality to compare array elements.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>find_opt f a</code> returns the first element of the array <code>a</code> that satisfies the predicate <code>f</code>, or <code>None</code> if there is no value that satisfies <code>f</code> in the array <code>a</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.13</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_index"><a href="#val-find_index" class="anchor"></a><code><span><span class="keyword">val</span> find_index : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span>int option</span></span></code></div><div class="spec-doc"><p><code>find_index f a</code> returns <code>Some i</code>, where <code>i</code> is the index of the first element of the array <code>a</code> that satisfies <code>f x</code>, if there is such an element.</p><p>It returns <code>None</code> if there is no such element.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.1</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_map"><a href="#val-find_map" class="anchor"></a><code><span><span class="keyword">val</span> find_map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p><code>find_map f a</code> applies <code>f</code> to the elements of <code>a</code> in order, and returns the first result of the form <code>Some v</code>, or <code>None</code> if none exist.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.13</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_mapi"><a href="#val-find_mapi" class="anchor"></a><code><span><span class="keyword">val</span> find_mapi : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span></span></code></div><div class="spec-doc"><p>Same as <code>find_map</code>, but the predicate is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.1</li></ul></div></div><h2 id="arrays-of-pairs"><a href="#arrays-of-pairs" class="anchor"></a>Arrays of pairs</h2><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span> * <span><span class="type-var">'b</span> array</span></span></code></div><div class="spec-doc"><p><code>split [|(a1,b1); ...; (an,bn)|]</code> is <code>([|a1; ...; an|], [|b1; ...; bn|])</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.13</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-combine"><a href="#val-combine" class="anchor"></a><code><span><span class="keyword">val</span> combine : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> array</span></span></code></div><div class="spec-doc"><p><code>combine [|a1; ...; an|] [|b1; ...; bn|]</code> is <code>[|(a1,b1); ...; (an,bn)|]</code>. Raise <code>Invalid_argument</code> if the two arrays have different lengths.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.13</li></ul></div></div><h2 id="sorting_and_shuffling"><a href="#sorting_and_shuffling" class="anchor"></a>Sorting and shuffling</h2><div class="odoc-spec"><div class="spec value anchored" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span><span class="keyword">val</span> sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, <a href="../index.html#val-compare"><code>Stdlib.compare</code></a> is a suitable comparison function. After calling <code>sort</code>, the array is sorted in place in increasing order. <code>sort</code> is guaranteed to run in constant heap space and (at most) logarithmic stack space.</p><p>The current implementation uses Heap Sort. It runs in constant stack space.</p><p>Specification of the comparison function: Let <code>a</code> be the array and <code>cmp</code> the comparison function. The following must be true for all <code>x</code>, <code>y</code>, <code>z</code> in <code>a</code> :</p><ul><li><code>cmp x y</code> &gt; 0 if and only if <code>cmp y x</code> &lt; 0</li><li>if <code>cmp x y</code> &gt;= 0 and <code>cmp y z</code> &gt;= 0 then <code>cmp x z</code> &gt;= 0</li></ul><p>When <code>sort</code> returns, <code>a</code> contains the same elements as before, reordered in such a way that for all i and j valid indices of <code>a</code> :</p><ul><li><code>cmp a.(i) a.(j)</code> &gt;= 0 if i &gt;= j</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stable_sort"><a href="#val-stable_sort" class="anchor"></a><code><span><span class="keyword">val</span> stable_sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-sort"><code>sort</code></a>, but the sorting algorithm is stable (i.e. elements that compare equal are kept in their original order) and not guaranteed to run in constant heap space.</p><p>The current implementation uses Merge Sort. It uses a temporary array of length <code>n/2</code>, where <code>n</code> is the length of the array. It is usually faster than the current implementation of <a href="#val-sort"><code>sort</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fast_sort"><a href="#val-fast_sort" class="anchor"></a><code><span><span class="keyword">val</span> fast_sort : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Same as <a href="#val-sort"><code>sort</code></a> or <a href="#val-stable_sort"><code>stable_sort</code></a>, whichever is faster on typical input.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shuffle"><a href="#val-shuffle" class="anchor"></a><code><span><span class="keyword">val</span> shuffle : <span><span class="label">rand</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>shuffle rand a</code> randomly permutes <code>a</code>'s element using <code>rand</code> for randomness. The distribution of permutations is uniform.</p><p><code>rand</code> must be such that a call to <code>rand n</code> returns a uniformly distributed random number in the range [<code>0</code>;<code>n-1</code>]. <a href="../Random/index.html#val-int"><code>Random.int</code></a> can be used for this (do not forget to <a href="../Random/index.html#val-self_init" title="Random.self_init">initialize</a> the generator).</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.2</li></ul></div></div><h2 id="arrays-and-sequences"><a href="#arrays-and-sequences" class="anchor"></a>Arrays and Sequences</h2><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the array, in increasing order. Modifications of the array during iteration will be reflected in the sequence.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_seqi"><a href="#val-to_seqi" class="anchor"></a><code><span><span class="keyword">val</span> to_seqi : <span><span><span class="type-var">'a</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span class="type-var">'a</span>)</span> <a href="../Seq/index.html#type-t">Seq.t</a></span></span></code></div><div class="spec-doc"><p>Iterate on the array, in increasing order, yielding indices along elements. Modifications of the array during iteration will be reflected in the sequence.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span class="type-var">'a</span> <a href="../Seq/index.html#type-t">Seq.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p>Create an array from the generator</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.07</li></ul></div></div><h2 id="array_concurrency"><a href="#array_concurrency" class="anchor"></a>Arrays and concurrency safety</h2><p>Care must be taken when concurrently accessing arrays from multiple domains: accessing an array will never crash a program, but unsynchronized accesses might yield surprising (non-sequentially-consistent) results.</p><h3 id="array_atomicity"><a href="#array_atomicity" class="anchor"></a>Atomicity</h3><p>Every array operation that accesses more than one array element is not atomic. This includes iteration, scanning, sorting, splitting and combining arrays.</p><p>For example, consider the following program:</p><pre class="language-ocaml"><code>let size = 100_000_000
let a = Array.make size 1
let d1 = Domain.spawn (fun () -&gt;
   Array.iteri (fun i x -&gt; a.(i) &lt;- x + 1) a
)
let d2 = Domain.spawn (fun () -&gt;
  Array.iteri (fun i x -&gt; a.(i) &lt;- 2 * x + 1) a
)
let () = Domain.join d1; Domain.join d2</code></pre><p>After executing this code, each field of the array <code>a</code> is either <code>2</code>, <code>3</code>, <code>4</code> or <code>5</code>. If atomicity is required, then the user must implement their own synchronization (for example, using <a href="../Mutex/index.html#type-t"><code>Mutex.t</code></a>).</p><h3 id="array_data_race"><a href="#array_data_race" class="anchor"></a>Data races</h3><p>If two domains only access disjoint parts of the array, then the observed behaviour is the equivalent to some sequential interleaving of the operations from the two domains.</p><p>A data race is said to occur when two domains access the same array element without synchronization and at least one of the accesses is a write. In the absence of data races, the observed behaviour is equivalent to some sequential interleaving of the operations from different domains.</p><p>Whenever possible, data races should be avoided by using synchronization to mediate the accesses to the array elements.</p><p>Indeed, in the presence of data races, programs will not crash but the observed behaviour may not be equivalent to any sequential interleaving of operations from different domains. Nevertheless, even in the presence of data races, a read operation will return the value of some prior write to that location (with a few exceptions for float arrays).</p><h3 id="array_data_race_exceptions"><a href="#array_data_race_exceptions" class="anchor"></a>Float arrays</h3><p>Float arrays have two supplementary caveats in the presence of data races.</p><p>First, the blit operation might copy an array byte-by-byte. Data races between such a blit operation and another operation might produce surprising values due to tearing: partial writes interleaved with other operations can create float values that would not exist with a sequential execution.</p><p>For instance, at the end of</p><pre class="language-ocaml"><code> let zeros = Array.make size 0.
let max_floats = Array.make size Float.max_float
let res = Array.copy zeros
let d1 = Domain.spawn (fun () -&gt; Array.blit zeros 0 res 0 size)
let d2 = Domain.spawn (fun () -&gt; Array.blit max_floats 0 res 0 size)
let () = Domain.join d1; Domain.join d2</code></pre><p>the <code>res</code> array might contain values that are neither <code>0.</code> nor <code>max_float</code>.</p><p>Second, on 32-bit architectures, getting or setting a field involves two separate memory accesses. In the presence of data races, the user may observe tearing on any operation.</p></div></body></html>
