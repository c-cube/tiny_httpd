<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Condition (ocaml.Stdlib.Condition)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ocaml</a> &#x00BB; <a href="../index.html">Stdlib</a> &#x00BB; Condition</nav><header class="odoc-preamble"><h1>Module <code><span>Stdlib.Condition</span></code></h1><p>Condition variables.</p><p>Condition variables are useful when several threads wish to access a shared data structure that is protected by a mutex (a mutual exclusion lock).</p><p>A condition variable is a <i>communication channel</i>. On the receiver side, one or more threads can indicate that they wish to <i>wait</i> for a certain property to become true. On the sender side, a thread can <i>signal</i> that this property has become true, causing one (or more) waiting threads to be woken up.</p><p>For instance, in the implementation of a queue data structure, if a thread that wishes to extract an element finds that the queue is currently empty, then this thread waits for the queue to become nonempty. A thread that inserts an element into the queue signals that the queue has become nonempty. A condition variable is used for this purpose. This communication channel conveys the information that the property &quot;the queue is nonempty&quot; is true, or more accurately, may be true. (We explain below why the receiver of a signal cannot be certain that the property holds.)</p><p>To continue the example of the queue, assuming that the queue has a fixed maximum capacity, then a thread that wishes to insert an element may find that the queue is full. Then, this thread must wait for the queue to become not full, and a thread that extracts an element of the queue signals that the queue has become not full. Another condition variable is used for this purpose.</p><p>In short, a condition variable <code>c</code> is used to convey the information that a certain property <i>P</i> about a shared data structure <i>D</i>, protected by a mutex <code>m</code>, may be true.</p><p>Condition variables provide an efficient alternative to busy-waiting. When one wishes to wait for the property <i>P</i> to be true, instead of writing a busy-waiting loop:</p><pre class="language-ocaml"><code>  Mutex.lock m;
  while not P do
    Mutex.unlock m; Mutex.lock m
  done;
  &lt;update the data structure&gt;;
  Mutex.unlock m</code></pre><p>one uses <a href="#val-wait"><code>wait</code></a> in the body of the loop, as follows:</p><pre class="language-ocaml"><code>  Mutex.lock m;
  while not P do
    Condition.wait c m
  done;
  &lt;update the data structure&gt;;
  Mutex.unlock m</code></pre><p>The busy-waiting loop is inefficient because the waiting thread consumes processing time and creates contention of the mutex <code>m</code>. Calling <a href="#val-wait"><code>wait</code></a> allows the waiting thread to be suspended, so it does not consume any computing resources while waiting.</p><p>With a condition variable <code>c</code>, exactly one mutex <code>m</code> is associated. This association is implicit: the mutex <code>m</code> is not explicitly passed as an argument to <a href="#val-create"><code>create</code></a>. It is up to the programmer to know, for each condition variable <code>c</code>, which is the associated mutex <code>m</code>.</p><p>With a mutex <code>m</code>, several condition variables can be associated. In the example of the bounded queue, one condition variable is used to indicate that the queue is nonempty, and another condition variable is used to indicate that the queue is not full.</p><p>With a condition variable <code>c</code>, exactly one logical property <i>P</i> should be associated. Examples of such properties include &quot;the queue is nonempty&quot; and &quot;the queue is not full&quot;. It is up to the programmer to keep track, for each condition variable, of the corresponding property <i>P</i>. A signal is sent on the condition variable <code>c</code> as an indication that the property <i>P</i> is true, or may be true. On the receiving end, however, a thread that is woken up cannot assume that <i>P</i> is true; after a call to <a href="#val-wait"><code>wait</code></a> terminates, one must explicitly test whether <i>P</i> is true. There are several reasons why this is so. One reason is that, between the moment when the signal is sent and the moment when a waiting thread receives the signal and is scheduled, the property <i>P</i> may be falsified by some other thread that is able to acquire the mutex <code>m</code> and alter the data structure <i>D</i>. Another reason is that <i>spurious wakeups</i> may occur: a waiting thread can be woken up even if no signal was sent.</p><p>Here is a complete example, where a mutex protects a sequential unbounded queue, and where a condition variable is used to signal that the queue is nonempty.</p><pre class="language-ocaml"><code>  type 'a safe_queue =
    { queue : 'a Queue.t; mutex : Mutex.t; nonempty : Condition.t }

  let create () =
    { queue = Queue.create(); mutex = Mutex.create();
      nonempty = Condition.create() }

  let add v q =
    Mutex.lock q.mutex;
    let was_empty = Queue.is_empty q.queue in
    Queue.add v q.queue;
    if was_empty then Condition.broadcast q.nonempty;
    Mutex.unlock q.mutex

  let take q =
    Mutex.lock q.mutex;
    while Queue.is_empty q.queue do Condition.wait q.nonempty q.mutex done;
    let v = Queue.take q.queue in (* cannot fail since queue is nonempty *)
    Mutex.unlock q.mutex;
    v</code></pre><p>Because the call to <a href="#val-broadcast"><code>broadcast</code></a> takes place inside the critical section, the following property holds whenever the mutex is unlocked: <i>if the queue is nonempty, then no thread is waiting</i>, or, in other words, <i>if some thread is waiting, then the queue must be empty</i>. This is a desirable property: if a thread that attempts to execute a <code>take</code> operation could remain suspended even though the queue is nonempty, that would be a problematic situation, known as a <i>deadlock</i>.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>The type of condition variables.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>create()</code> creates and returns a new condition variable. This condition variable should be associated (in the programmer's mind) with a certain mutex <code>m</code> and with a certain property <i>P</i> of the data structure that is protected by the mutex <code>m</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-wait"><a href="#val-wait" class="anchor"></a><code><span><span class="keyword">val</span> wait : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Mutex/index.html#type-t">Mutex.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>The call <code>wait c m</code> is permitted only if <code>m</code> is the mutex associated with the condition variable <code>c</code>, and only if <code>m</code> is currently locked. This call atomically unlocks the mutex <code>m</code> and suspends the current thread on the condition variable <code>c</code>. This thread can later be woken up after the condition variable <code>c</code> has been signaled via <a href="#val-signal"><code>signal</code></a> or <a href="#val-broadcast"><code>broadcast</code></a>; however, it can also be woken up for no reason. The mutex <code>m</code> is locked again before <code>wait</code> returns. One cannot assume that the property <i>P</i> associated with the condition variable <code>c</code> holds when <code>wait</code> returns; one must explicitly test whether <i>P</i> holds after calling <code>wait</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-signal"><a href="#val-signal" class="anchor"></a><code><span><span class="keyword">val</span> signal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>signal c</code> wakes up one of the threads waiting on the condition variable <code>c</code>, if there is one. If there is none, this call has no effect.</p><p>It is recommended to call <code>signal c</code> inside a critical section, that is, while the mutex <code>m</code> associated with <code>c</code> is locked.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-broadcast"><a href="#val-broadcast" class="anchor"></a><code><span><span class="keyword">val</span> broadcast : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>broadcast c</code> wakes up all threads waiting on the condition variable <code>c</code>. If there are none, this call has no effect.</p><p>It is recommended to call <code>broadcast c</code> inside a critical section, that is, while the mutex <code>m</code> associated with <code>c</code> is locked.</p></div></div></div></body></html>
