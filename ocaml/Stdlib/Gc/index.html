<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Gc (ocaml.Stdlib.Gc)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ocaml</a> &#x00BB; <a href="../index.html">Stdlib</a> &#x00BB; Gc</nav><header class="odoc-preamble"><h1>Module <code><span>Stdlib.Gc</span></code></h1><p>Memory management control and statistics; finalised values.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-stat"><a href="#type-stat" class="anchor"></a><code><span><span class="keyword">type</span> stat</span><span> = </span><span>{</span></code><ol><li id="type-stat.minor_words" class="def record field anchored"><a href="#type-stat.minor_words" class="anchor"></a><code><span>minor_words : float;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of words allocated in the minor heap since the program was started.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.promoted_words" class="def record field anchored"><a href="#type-stat.promoted_words" class="anchor"></a><code><span>promoted_words : float;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.major_words" class="def record field anchored"><a href="#type-stat.major_words" class="anchor"></a><code><span>major_words : float;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of words allocated in the major heap, including the promoted words, since the program was started.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.minor_collections" class="def record field anchored"><a href="#type-stat.minor_collections" class="anchor"></a><code><span>minor_collections : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of minor collections since the program was started.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.major_collections" class="def record field anchored"><a href="#type-stat.major_collections" class="anchor"></a><code><span>major_collections : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of major collection cycles completed since the program was started.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.heap_words" class="def record field anchored"><a href="#type-stat.heap_words" class="anchor"></a><code><span>heap_words : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Total size of the major heap, in words.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.heap_chunks" class="def record field anchored"><a href="#type-stat.heap_chunks" class="anchor"></a><code><span>heap_chunks : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of contiguous pieces of memory that make up the major heap. This metric is currently not available in OCaml 5: the field value is always <code>0</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.live_words" class="def record field anchored"><a href="#type-stat.live_words" class="anchor"></a><code><span>live_words : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of words of live data in the major heap, including the header words.</p><p>Note that &quot;live&quot; words refers to every word in the major heap that isn't currently known to be collectable, which includes words that have become unreachable by the program after the start of the previous gc cycle. It is typically much simpler and more predictable to call <a href="#val-full_major"><code>Gc.full_major</code></a> (or <a href="#val-compact"><code>Gc.compact</code></a>) then computing gc stats, as then &quot;live&quot; words has the simple meaning of &quot;reachable by the program&quot;. One caveat is that a single call to <a href="#val-full_major"><code>Gc.full_major</code></a> will not reclaim values that have a finaliser from <a href="#val-finalise"><code>Gc.finalise</code></a> (this does not apply to <a href="#val-finalise_last"><code>Gc.finalise_last</code></a>). If this caveat matters, simply call <a href="#val-full_major"><code>Gc.full_major</code></a> twice instead of once.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.live_blocks" class="def record field anchored"><a href="#type-stat.live_blocks" class="anchor"></a><code><span>live_blocks : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of live blocks in the major heap.</p><p>See <code>live_words</code> for a caveat about what &quot;live&quot; means.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.free_words" class="def record field anchored"><a href="#type-stat.free_words" class="anchor"></a><code><span>free_words : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of words in the free list.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.free_blocks" class="def record field anchored"><a href="#type-stat.free_blocks" class="anchor"></a><code><span>free_blocks : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of blocks in the free list. This metric is currently not available in OCaml 5: the field value is always <code>0</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.largest_free" class="def record field anchored"><a href="#type-stat.largest_free" class="anchor"></a><code><span>largest_free : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Size (in words) of the largest block in the free list. This metric is currently not available in OCaml 5: the field value is always <code>0</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.fragments" class="def record field anchored"><a href="#type-stat.fragments" class="anchor"></a><code><span>fragments : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.compactions" class="def record field anchored"><a href="#type-stat.compactions" class="anchor"></a><code><span>compactions : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of heap compactions since the program was started.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.top_heap_words" class="def record field anchored"><a href="#type-stat.top_heap_words" class="anchor"></a><code><span>top_heap_words : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Maximum size reached by the major heap, in words.</p><span class="comment-delim">*)</span></div></li><li id="type-stat.stack_size" class="def record field anchored"><a href="#type-stat.stack_size" class="anchor"></a><code><span>stack_size : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Current size of the stack, in words. This metric is currently not available in OCaml 5: the field value is always <code>0</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.12</li></ul><span class="comment-delim">*)</span></div></li><li id="type-stat.forced_major_collections" class="def record field anchored"><a href="#type-stat.forced_major_collections" class="anchor"></a><code><span>forced_major_collections : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Number of forced full major collections completed since the program was started.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.12</li></ul><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The memory management counters are returned in a <code>stat</code> record. These counters give values for the whole program.</p><p>The total amount of memory allocated by the program since it was started is (in words) <code>minor_words + major_words - promoted_words</code>. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-control"><a href="#type-control" class="anchor"></a><code><span><span class="keyword">type</span> control</span><span> = </span><span>{</span></code><ol><li id="type-control.minor_heap_size" class="def record field anchored"><a href="#type-control.minor_heap_size" class="anchor"></a><code><span>minor_heap_size : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The size (in words) of the minor heap. Changing this parameter will trigger a minor collection. The total size of the minor heap used by this program is the sum of the heap sizes of the active domains. Default: 256k.</p><span class="comment-delim">*)</span></div></li><li id="type-control.major_heap_increment" class="def record field anchored"><a href="#type-control.major_heap_increment" class="anchor"></a><code><span>major_heap_increment : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>How much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap.</p><p>This field is currently not available in OCaml 5: the field value is always <code>0</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-control.space_overhead" class="def record field anchored"><a href="#type-control.space_overhead" class="anchor"></a><code><span>space_overhead : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The major GC speed is computed from this parameter. This is the memory that will be &quot;wasted&quot; because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if <code>space_overhead</code> is smaller. Default: 120.</p><span class="comment-delim">*)</span></div></li><li id="type-control.verbose" class="def record field anchored"><a href="#type-control.verbose" class="anchor"></a><code><span>verbose : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:</p><ul><li><code>0x001</code> Start and end of major GC cycle.</li><li><code>0x002</code> Minor collection and major GC slice.</li><li><code>0x004</code> Growing and shrinking of the heap.</li><li><code>0x008</code> Resizing of stacks and memory manager tables.</li><li><code>0x010</code> Heap compaction.</li><li><code>0x020</code> Change of GC parameters.</li><li><code>0x040</code> Computation of major GC slice size.</li><li><code>0x080</code> Calling of finalisation functions.</li><li><code>0x100</code> Bytecode executable and shared library search at start-up.</li><li><code>0x200</code> Computation of compaction-triggering condition.</li><li><code>0x400</code> Output GC statistics at program exit. Default: 0.</li></ul><span class="comment-delim">*)</span></div></li><li id="type-control.max_overhead" class="def record field anchored"><a href="#type-control.max_overhead" class="anchor"></a><code><span>max_overhead : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Heap compaction is triggered when the estimated amount of &quot;wasted&quot; memory is more than <code>max_overhead</code> percent of the amount of live data. If <code>max_overhead</code> is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If <code>max_overhead &gt;= 1000000</code>, compaction is never triggered.</p><p>This field is currently not available in OCaml 5: the field value is always <code>0</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-control.stack_limit" class="def record field anchored"><a href="#type-control.stack_limit" class="anchor"></a><code><span>stack_limit : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The maximum size of the fiber stacks (in words). Default: 128M.</p><span class="comment-delim">*)</span></div></li><li id="type-control.allocation_policy" class="def record field anchored"><a href="#type-control.allocation_policy" class="anchor"></a><code><span>allocation_policy : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The policy used for allocating in the major heap.</p><p>This field is currently not available in OCaml 5: the field value is always <code>0</code>.</p><p>Prior to OCaml 5.0, possible values were 0, 1 and 2.</p><ul><li>0 was the next-fit policy</li></ul><ul><li>1 was the first-fit policy (since OCaml 3.11)</li></ul><ul><li>2 was the best-fit policy (since OCaml 4.10)</li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.11</li></ul><span class="comment-delim">*)</span></div></li><li id="type-control.window_size" class="def record field anchored"><a href="#type-control.window_size" class="anchor"></a><code><span>window_size : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The size of the window used by the major GC for smoothing out variations in its workload. This is an integer between 1 and 50.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03</li></ul><p>This field is currently not available in OCaml 5: the field value is always <code>0</code>.</p><span class="comment-delim">*)</span></div></li><li id="type-control.custom_major_ratio" class="def record field anchored"><a href="#type-control.custom_major_ratio" class="anchor"></a><code><span>custom_major_ratio : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Target ratio of floating garbage to major heap size for out-of-heap memory held by custom values located in the major heap. The GC speed is adjusted to try to use this much memory for dead values that are not yet collected. Expressed as a percentage of major heap size. The default value keeps the out-of-heap floating garbage about the same size as the in-heap overhead. Note: this only applies to values allocated with <code>caml_alloc_custom_mem</code> (e.g. bigarrays). Default: 44.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.08</li></ul><span class="comment-delim">*)</span></div></li><li id="type-control.custom_minor_ratio" class="def record field anchored"><a href="#type-control.custom_minor_ratio" class="anchor"></a><code><span>custom_minor_ratio : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Bound on floating garbage for out-of-heap memory held by custom values in the minor heap. A minor GC is triggered when this much memory is held by custom values located in the minor heap. Expressed as a percentage of minor heap size. Note: this only applies to values allocated with <code>caml_alloc_custom_mem</code> (e.g. bigarrays). Default: 100.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.08</li></ul><span class="comment-delim">*)</span></div></li><li id="type-control.custom_minor_max_size" class="def record field anchored"><a href="#type-control.custom_minor_max_size" class="anchor"></a><code><span>custom_minor_max_size : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Maximum amount of out-of-heap memory for each custom value allocated in the minor heap. Custom values that hold more than this many bytes are allocated on the major heap. Note: this only applies to values allocated with <code>caml_alloc_custom_mem</code> (e.g. bigarrays). Default: 70000 bytes.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.08</li></ul><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The GC parameters are given as a <code>control</code> record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of <code>ocamlrun</code>.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-stat"><a href="#val-stat" class="anchor"></a><code><span><span class="keyword">val</span> stat : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-stat">stat</a></span></code></div><div class="spec-doc"><p>Return the current values of the memory management counters in a <code>stat</code> record that represents the program's total memory stats. The <code>heap_chunks</code>, <code>free_blocks</code>, <code>largest_free</code>, and <code>stack_size</code> metrics are currently not available in OCaml 5: their returned field values are therefore <code>0</code>. This function causes a full major collection.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-quick_stat"><a href="#val-quick_stat" class="anchor"></a><code><span><span class="keyword">val</span> quick_stat : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-stat">stat</a></span></code></div><div class="spec-doc"><p>Returns a record with the current values of the memory management counters like <code>stat</code>. Unlike <code>stat</code>, <code>quick_stat</code> does not perform a full major collection, and hence, is much faster. However, <code>quick_stat</code> reports the counters sampled at the last minor collection or at the end of the last major collection cycle (whichever is the latest). Hence, the memory stats returned by <code>quick_stat</code> are not instantaneously accurate.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-counters"><a href="#val-counters" class="anchor"></a><code><span><span class="keyword">val</span> counters : <span>unit <span class="arrow">&#45;&gt;</span></span> float * float * float</span></code></div><div class="spec-doc"><p>Return <code>(minor_words, promoted_words, major_words)</code> for the current domain or potentially previous domains. This function is as fast as <code>quick_stat</code>.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-minor_words"><a href="#val-minor_words" class="anchor"></a><code><span><span class="keyword">val</span> minor_words : <span>unit <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Number of words allocated in the minor heap by this domain or potentially previous domains. This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.</p><p>In native code this function does not allocate.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.04</li></ul></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-control">control</a></span></code></div><div class="spec-doc"><p>Return the current values of the GC parameters in a <code>control</code> record.</p><p>The <code>major_heap_increment</code>, <code>max_overhead</code>, <code>allocation_policy</code>, and <code>window_size</code> fields are currently not available in OCaml 5: their returned field values are therefore <code>0</code>.</p><ul class="at-tags"><li class="alert"><span class="at-tag">alert</span> unsynchronized_access GC parameters are a mutable global state.</li></ul></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><a href="#type-control">control</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set r</code> changes the GC parameters according to the <code>control</code> record <code>r</code>. The normal usage is: <code>Gc.set { (Gc.get()) with Gc.verbose = 0x00d }</code></p><p>The <code>major_heap_increment</code>, <code>max_overhead</code>, <code>allocation_policy</code>, and <code>window_size</code> fields are currently not available in OCaml 5: setting them therefore has no effect.</p><ul class="at-tags"><li class="alert"><span class="at-tag">alert</span> unsynchronized_access GC parameters are a mutable global state.</li></ul></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-minor"><a href="#val-minor" class="anchor"></a><code><span><span class="keyword">val</span> minor : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Trigger a minor collection.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-major_slice"><a href="#val-major_slice" class="anchor"></a><code><span><span class="keyword">val</span> major_slice : <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>major_slice n</code> Do a minor collection and a slice of major collection. <code>n</code> is the size of the slice: the GC will do enough work to free (on average) <code>n</code> words of memory. If <code>n</code> = 0, the GC will try to do enough work to ensure that the next automatic slice has no work to do. This function returns an unspecified integer (currently: 0).</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-major"><a href="#val-major" class="anchor"></a><code><span><span class="keyword">val</span> major : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Do a minor collection and finish the current major collection cycle.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-full_major"><a href="#val-full_major" class="anchor"></a><code><span><span class="keyword">val</span> full_major : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-compact"><a href="#val-compact" class="anchor"></a><code><span><span class="keyword">val</span> compact : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-print_stat"><a href="#val-print_stat" class="anchor"></a><code><span><span class="keyword">val</span> print_stat : <span><a href="../index.html#type-out_channel">out_channel</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print the current values of the memory management counters (in human-readable form) of the total program into the channel argument.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-allocated_bytes"><a href="#val-allocated_bytes" class="anchor"></a><code><span><span class="keyword">val</span> allocated_bytes : <span>unit <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p>Return the number of bytes allocated by this domain and potentially a previous domain. It is returned as a <code>float</code> to avoid overflow problems with <code>int</code> on 32-bit machines.</p></div></div><div class="odoc-spec"><div class="spec value external anchored" id="val-get_minor_free"><a href="#val-get_minor_free" class="anchor"></a><code><span><span class="keyword">val</span> get_minor_free : <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the current size of the free space inside the minor heap of this domain.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.03</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-finalise"><a href="#val-finalise" class="anchor"></a><code><span><span class="keyword">val</span> finalise : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>finalise f v</code> registers <code>f</code> as a finalisation function for <code>v</code>. <code>v</code> must be heap-allocated. <code>f</code> will be called with <code>v</code> as argument at some point between the first time <code>v</code> becomes unreachable (including through weak pointers) and the time <code>v</code> is collected by the GC. Several functions can be registered for the same value, or even several instances of the same function. Each instance will be called once (or never, if the program terminates before <code>v</code> becomes unreachable).</p><p>The GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to <code>finalise</code>. If <code>finalise</code> is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.</p><p>In the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.</p><p>Anything reachable from the closure of finalisation functions is considered reachable, so the following code will not work as expected:</p><ul><li><code> let v = ... in Gc.finalise (fun _ -&gt; ...v...) v </code></li></ul><p>Instead you should make sure that <code>v</code> is not in the closure of the finalisation function by writing:</p><ul><li><code> let f = fun x -&gt; ...  let v = ... in Gc.finalise f v </code></li></ul><p>The <code>f</code> function can use all features of OCaml, including assignments that make the value reachable again. It can also loop forever (in this case, the other finalisation functions will not be called during the execution of f, unless it calls <code>finalise_release</code>). It can call <code>finalise</code> on <code>v</code> or other values to register other functions or even itself. It can raise an exception; in this case the exception will interrupt whatever the program was doing when the function was called.</p><p><code>finalise</code> will raise <code>Invalid_argument</code> if <code>v</code> is not guaranteed to be heap-allocated. Some examples of values that are not heap-allocated are integers, constant constructors, booleans, the empty array, the empty list, the unit value. The exact list of what is heap-allocated or not is implementation-dependent. Some constant values can be heap-allocated but never deallocated during the lifetime of the program, for example a list of integer constants; this is also implementation-dependent. Note that values of types <code>float</code> are sometimes allocated and sometimes not, so finalising them is unsafe, and <code>finalise</code> will also raise <code>Invalid_argument</code> for them. Values of type <code>'a Lazy.t</code> (for any <code>'a</code>) are like <code>float</code> in this respect, except that the compiler sometimes optimizes them in a way that prevents <code>finalise</code> from detecting them. In this case, it will not raise <code>Invalid_argument</code>, but you should still avoid calling <code>finalise</code> on lazy values.</p><p>The results of calling <a href="../String/index.html#val-make"><code>String.make</code></a>, <a href="../Bytes/index.html#val-make"><code>Bytes.make</code></a>, <a href="../Bytes/index.html#val-create"><code>Bytes.create</code></a>, <a href="../Array/index.html#val-make"><code>Array.make</code></a>, and <a href="../index.html#val-ref"><code>Stdlib.ref</code></a> are guaranteed to be heap-allocated and non-constant except when the length argument is <code>0</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-finalise_last"><a href="#val-finalise_last" class="anchor"></a><code><span><span class="keyword">val</span> finalise_last : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>same as <a href="#val-finalise"><code>finalise</code></a> except the value is not given as argument. So you can't use the given value for the computation of the finalisation function. The benefit is that the function is called after the value is unreachable for the last time instead of the first time. So contrary to <a href="#val-finalise"><code>finalise</code></a> the value will never be reachable again or used again. In particular every weak pointer and ephemeron that contained this value as key or data is unset before running the finalisation function. Moreover the finalisation functions attached with <a href="#val-finalise"><code>finalise</code></a> are always called before the finalisation functions attached with <a href="#val-finalise_last"><code>finalise_last</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.04</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-finalise_release"><a href="#val-finalise_release" class="anchor"></a><code><span><span class="keyword">val</span> finalise_release : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>A finalisation function may call <code>finalise_release</code> to tell the GC that it can launch the next finalisation function without waiting for the current one to return.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-alarm"><a href="#type-alarm" class="anchor"></a><code><span><span class="keyword">type</span> alarm</span></code></div><div class="spec-doc"><p>An alarm is a piece of data that calls a user function at the end of major GC cycle. The following functions are provided to create and delete alarms.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_alarm"><a href="#val-create_alarm" class="anchor"></a><code><span><span class="keyword">val</span> create_alarm : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-alarm">alarm</a></span></code></div><div class="spec-doc"><p><code>create_alarm f</code> will arrange for <code>f</code> to be called at the end of major GC cycles, not caused by <code>f</code> itself, starting with the current cycle or the next one. <code>f</code> will run on the same domain that created the alarm, until the domain exits or <code>delete_alarm</code> is called. A value of type <code>alarm</code> is returned that you can use to call <code>delete_alarm</code>.</p><p>It is not guaranteed that the Gc alarm runs at the end of every major GC cycle, but it is guaranteed that it will run eventually.</p><p>As an example, here is a crude way to interrupt a function if the memory consumption of the program exceeds a given <code>limit</code> in MB, suitable for use in the toplevel:</p><pre class="language-ocaml"><code>let run_with_memory_limit (limit : int) (f : unit -&gt; 'a) : 'a =
  let limit_memory () =
    let mem = Gc.(quick_stat ()).heap_words in
    if mem / (1024 * 1024) &gt; limit / (Sys.word_size / 8) then
      raise Out_of_memory
  in
  let alarm = Gc.create_alarm limit_memory in
  Fun.protect f ~finally:(fun () -&gt; Gc.delete_alarm alarm ; Gc.compact ())</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-delete_alarm"><a href="#val-delete_alarm" class="anchor"></a><code><span><span class="keyword">val</span> delete_alarm : <span><a href="#type-alarm">alarm</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>delete_alarm a</code> will stop the calls to the function associated to <code>a</code>. Calling <code>delete_alarm a</code> again has no effect.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eventlog_pause"><a href="#val-eventlog_pause" class="anchor"></a><code><span><span class="keyword">val</span> eventlog_pause : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Runtime_events.pause instead.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-eventlog_resume"><a href="#val-eventlog_resume" class="anchor"></a><code><span><span class="keyword">val</span> eventlog_resume : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> Use Runtime_events.resume instead.</li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Memprof"><a href="#module-Memprof" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Memprof/index.html">Memprof</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Memprof</code> is a profiling engine which randomly samples allocated memory words. Every allocated word has a probability of being sampled equal to a configurable sampling rate. Once a block is sampled, it becomes tracked. A tracked block triggers a user-defined callback as soon as it is allocated, promoted or deallocated.</p></div></div></div></body></html>
