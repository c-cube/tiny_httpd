<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Scanf (ocaml.Stdlib.Scanf)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">ocaml</a> &#x00BB; <a href="../index.html">Stdlib</a> &#x00BB; Scanf</nav><header class="odoc-preamble"><h1>Module <code><span>Stdlib.Scanf</span></code></h1><p>Formatted input functions.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#introduction">Introduction</a><ul><li><a href="#functional-input-with-format-strings">Functional input with format strings</a></li><li><a href="#a-simple-example">A simple example</a></li><li><a href="#formatted-input-as-a-functional-feature">Formatted input as a functional feature</a></li></ul></li><li><a href="#formatted-input-channel">Formatted input channel</a></li><li><a href="#type-of-formatted-input-functions">Type of formatted input functions</a></li><li><a href="#the-general-formatted-input-function">The general formatted input function</a></li><li><a href="#format-string-description">Format string description</a><ul><li><a href="#space">The space character in format strings</a></li><li><a href="#conversion">Conversion specifications in format strings</a></li><li><a href="#indication">Scanning indications in format strings</a></li><li><a href="#exceptions-during-scanning">Exceptions during scanning</a></li></ul></li><li><a href="#specialised-formatted-input-functions">Specialised formatted input functions</a></li><li><a href="#reading-format-strings-from-input">Reading format strings from input</a></li></ul></nav></div><div class="odoc-content"><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2><h3 id="functional-input-with-format-strings"><a href="#functional-input-with-format-strings" class="anchor"></a>Functional input with format strings</h3><p>The module <a href="#"><code>Scanf</code></a> provides formatted input functions or <em>scanners</em>.</p><p>The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a <em>formatted input channel</em> (or <em>scanning buffer</em>) and has type <a href="Scanning/index.html#type-in_channel"><code>Scanning.in_channel</code></a>. The more general formatted input function reads from any scanning buffer and is named <code>bscanf</code>.</p><p>Generally speaking, the formatted input functions have 3 arguments:</p><ul><li>the first argument is a source of characters for the input,</li><li>the second argument is a format string that specifies the values to read,</li><li>the third argument is a <em>receiver function</em> that is applied to the values read.</li></ul><p>Hence, a typical call to the formatted input function <a href="#val-bscanf"><code>Scanf.bscanf</code></a> is <code>bscanf ic fmt f</code>, where:</p><ul><li><code>ic</code> is a source of characters (typically a <em>formatted input channel</em> with type <a href="Scanning/index.html#type-in_channel"><code>Scanning.in_channel</code></a>),</li></ul><ul><li><code>fmt</code> is a format string (the same format strings as those used to print material with module <a href="../Printf/index.html"><code>Printf</code></a> or <a href="../Format/index.html"><code>Format</code></a>),</li></ul><ul><li><code>f</code> is a function that has as many arguments as the number of values to read in the input according to <code>fmt</code>.</li></ul><h3 id="a-simple-example"><a href="#a-simple-example" class="anchor"></a>A simple example</h3><p>As suggested above, the expression <code>bscanf ic &quot;%d&quot; f</code> reads a decimal integer <code>n</code> from the source of characters <code>ic</code> and returns <code>f n</code>.</p><p>For instance,</p><ul><li>if we use <code>stdin</code> as the source of characters (<a href="Scanning/index.html#val-stdin"><code>Scanning.stdin</code></a> is the predefined formatted input channel that reads from standard input),</li></ul><ul><li>if we define the receiver <code>f</code> as <code>let f x = x + 1</code>,</li></ul><p>then <code>bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code>n</code> from the standard input and returns <code>f n</code> (that is <code>n + 1</code>). Thus, if we evaluate <code>bscanf stdin &quot;%d&quot; f</code>, and then enter <code>41</code> at the keyboard, the result we get is <code>42</code>.</p><h3 id="formatted-input-as-a-functional-feature"><a href="#formatted-input-as-a-functional-feature" class="anchor"></a>Formatted input as a functional feature</h3><p>The OCaml scanning facility is reminiscent of the corresponding C feature. However, it is also largely different, simpler, and yet more powerful: the formatted input functions are higher-order functionals and the parameter passing mechanism is just the regular function application not the variable assignment based mechanism which is typical for formatted input in imperative languages; the OCaml format strings also feature useful additions to easily define complex tokens; as expected within a functional programming language, the formatted input functions also support polymorphism, in particular arbitrary interaction with polymorphic user-defined scanners. Furthermore, the OCaml formatted input facility is fully type-checked at compile time.</p><p><b>Unsynchronized accesses</b></p><p>Unsynchronized accesses to a <a href="Scanning/index.html#type-in_channel"><code>Scanning.in_channel</code></a> may lead to an invalid <a href="Scanning/index.html#type-in_channel"><code>Scanning.in_channel</code></a> state. Thus, concurrent accesses to <a href="Scanning/index.html#type-in_channel"><code>Scanning.in_channel</code></a>s must be synchronized (for instance with a <a href="../Mutex/index.html#type-t"><code>Mutex.t</code></a>).</p><h2 id="formatted-input-channel"><a href="#formatted-input-channel" class="anchor"></a>Formatted input channel</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Scanning"><a href="#module-Scanning" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Scanning/index.html">Scanning</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="type-of-formatted-input-functions"><a href="#type-of-formatted-input-functions" class="anchor"></a>Type of formatted input functions</h2><div class="odoc-spec"><div class="spec type anchored" id="type-scanner"><a href="#type-scanner" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b, 'c, 'd) scanner</span></span><span> =
  <span><span><span>(<span class="type-var">'a</span>, <a href="Scanning/index.html#type-in_channel">Scanning.in_channel</a>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>, <span class="type-var">'d</span>)</span> <a href="../index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'c</span></span></code></div><div class="spec-doc"><p>The type of formatted input scanners: <code>('a, 'b, 'c, 'd) scanner</code> is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if <code>scan</code> is some formatted input function, then <code>scan ic fmt f</code> applies <code>f</code> to all the arguments specified by format string <code>fmt</code>, when <code>scan</code> has read those arguments from the <a href="Scanning/index.html#type-in_channel"><code>Scanning.in_channel</code></a> formatted input channel <code>ic</code>.</p><p>For instance, the <a href="#val-scanf"><code>Scanf.scanf</code></a> function below has type <code>('a, 'b, 'c, 'd) scanner</code>, since it is a formatted input function that reads from <a href="Scanning/index.html#val-stdin"><code>Scanning.stdin</code></a>: <code>scanf fmt f</code> applies <code>f</code> to the arguments specified by <code>fmt</code>, reading those arguments from <a href="../index.html#val-stdin"><code>Stdlib.stdin</code></a> as expected.</p><p>If the format <code>fmt</code> has some <code>%r</code> indications, the corresponding formatted input functions must be provided <em>before</em> receiver function <code>f</code>. For instance, if <code>read_elem</code> is an input function for values of type <code>t</code>, then <code>bscanf ic &quot;%r;&quot; read_elem f</code> reads a value <code>v</code> of type <code>t</code> followed by a <code>';'</code> character, and returns <code>f v</code>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.10</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-scanner_opt"><a href="#type-scanner_opt" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'b, 'c, 'd) scanner_opt</span></span><span> =
  <span><span><span>(<span class="type-var">'a</span>, <a href="Scanning/index.html#type-in_channel">Scanning.in_channel</a>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'d</span> option</span>, <span class="type-var">'d</span>)</span> <a href="../index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'c</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Scan_failure"><a href="#exception-Scan_failure" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Scan_failure</span> <span class="keyword">of</span> string</span></code></div><div class="spec-doc"><p>When the input can not be read according to the format string specification, formatted input functions typically raise exception <code>Scan_failure</code>.</p></div></div><h2 id="the-general-formatted-input-function"><a href="#the-general-formatted-input-function" class="anchor"></a>The general formatted input function</h2><div class="odoc-spec"><div class="spec value anchored" id="val-bscanf"><a href="#val-bscanf" class="anchor"></a><code><span><span class="keyword">val</span> bscanf : <span><a href="Scanning/index.html#type-in_channel">Scanning.in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div></div><p><code>bscanf ic fmt r1 ... rN f</code> reads characters from the <a href="Scanning/index.html#type-in_channel"><code>Scanning.in_channel</code></a> formatted input channel <code>ic</code> and converts them to values according to format string <code>fmt</code>. As a final step, receiver function <code>f</code> is applied to the values read and gives the result of the <code>bscanf</code> call.</p><p>For instance, if <code>f</code> is the function <code>fun s i -&gt; i + 1</code>, then <code>Scanf.sscanf &quot;x = 1&quot; &quot;%s = %i&quot; f</code> returns <code>2</code>.</p><p>Arguments <code>r1</code> to <code>rN</code> are user-defined input functions that read the argument corresponding to the <code>%r</code> conversions specified in the format string.</p><div class="odoc-spec"><div class="spec value anchored" id="val-bscanf_opt"><a href="#val-bscanf_opt" class="anchor"></a><code><span><span class="keyword">val</span> bscanf_opt : <span><a href="Scanning/index.html#type-in_channel">Scanning.in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner_opt">scanner_opt</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-bscanf"><code>Scanf.bscanf</code></a>, but returns <code>None</code> in case of scanning failure.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.0</li></ul></div></div><h2 id="format-string-description"><a href="#format-string-description" class="anchor"></a>Format string description</h2><p>The format string is a character string which contains three types of objects:</p><ul><li>plain characters, which are simply matched with the characters of the input (with a special case for space and line feed, see <a href="#space" title="space">The space character in format strings</a>),</li><li>conversion specifications, each of which causes reading and conversion of one argument for the function <code>f</code> (see <a href="#conversion" title="conversion">Conversion specifications in format strings</a>),</li><li>scanning indications to specify boundaries of tokens (see scanning <a href="#indication" title="indication">Scanning indications in format strings</a>).</li></ul><h3 id="space"><a href="#space" class="anchor"></a>The space character in format strings</h3><p>As mentioned above, a plain character in the format string is just matched with the next character of the input; however, two characters are special exceptions to this rule: the space character (<code>' '</code> or ASCII code 32) and the line feed character (<code>'\n'</code> or ASCII code 10). A space does not match a single space character, but any amount of 'whitespace' in the input. More precisely, a space inside the format string matches <em>any number</em> of tab, space, line feed and carriage return characters. Similarly, a line feed character in the format string matches either a single line feed or a carriage return followed by a line feed.</p><p>Matching <em>any</em> amount of whitespace, a space in the format string also matches no amount of whitespace at all; hence, the call <code>bscanf ib &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code>1</code> when reading an input with various whitespace in it, such as <code>Price = 1 $</code>, <code>Price  =  1    $</code>, or even <code>Price=1$</code>.</p><h3 id="conversion"><a href="#conversion" class="anchor"></a>Conversion specifications in format strings</h3><p>Conversion specifications consist in the <code>%</code> character, followed by an optional flag, an optional field width, and followed by one or two conversion characters.</p><p>The conversion characters and their meanings are:</p><ul><li><code>d</code>: reads an optionally signed decimal integer (<code>0-9</code>+).</li><li><code>i</code>: reads an optionally signed integer (usual input conventions for decimal (<code>0-9</code>+), hexadecimal (<code>0x[0-9a-f]+</code> and <code>0X[0-9A-F]+</code>), octal (<code>0o[0-7]+</code>), and binary (<code>0b[0-1]+</code>) notations are understood).</li><li><code>u</code>: reads an unsigned decimal integer.</li><li><code>x</code> or <code>X</code>: reads an unsigned hexadecimal integer (<code>[0-9a-fA-F]+</code>).</li><li><code>o</code>: reads an unsigned octal integer (<code>[0-7]+</code>).</li><li><p><code>s</code>: reads a string argument that spreads as much as possible, until the following bounding condition holds:</p><ul><li>a whitespace has been found (see <a href="#space" title="space">The space character in format strings</a>),</li><li>a scanning indication (see scanning <a href="#indication" title="indication">Scanning indications in format strings</a>) has been encountered,</li><li>the end-of-input has been reached.</li></ul><p>Hence, this conversion always succeeds: it returns an empty string if the bounding condition holds when the scan begins.</p></li><li><code>S</code>: reads a delimited string argument (delimiters and special escaped characters follow the lexical conventions of OCaml).</li><li><code>c</code>: reads a single character. To test the current input character without reading it, specify a null field width, i.e. use specification <code>%0c</code>. Raise <code>Invalid_argument</code>, if the field width specification is greater than 1.</li><li><code>C</code>: reads a single delimited character (delimiters and special escaped characters follow the lexical conventions of OCaml).</li><li><code>f</code>, <code>e</code>, <code>E</code>, <code>g</code>, <code>G</code>: reads an optionally signed floating-point number in decimal notation, in the style <code>dddd.ddd e/E+-dd</code>.</li><li><code>h</code>, <code>H</code>: reads an optionally signed floating-point number in hexadecimal notation.</li><li><code>F</code>: reads a floating point number according to the lexical conventions of OCaml (hence the decimal point is mandatory if the exponent part is not mentioned).</li><li><code>B</code>: reads a boolean argument (<code>true</code> or <code>false</code>).</li><li><code>b</code>: reads a boolean argument (for backward compatibility; do not use in new programs).</li><li><code>ld</code>, <code>li</code>, <code>lu</code>, <code>lx</code>, <code>lX</code>, <code>lo</code>: reads an <code>int32</code> argument to the format specified by the second letter for regular integers.</li><li><code>nd</code>, <code>ni</code>, <code>nu</code>, <code>nx</code>, <code>nX</code>, <code>no</code>: reads a <code>nativeint</code> argument to the format specified by the second letter for regular integers.</li><li><code>Ld</code>, <code>Li</code>, <code>Lu</code>, <code>Lx</code>, <code>LX</code>, <code>Lo</code>: reads an <code>int64</code> argument to the format specified by the second letter for regular integers.</li><li><code>[ range ]</code>: reads characters that matches one of the characters mentioned in the range of characters <code>range</code> (or not mentioned in it, if the range starts with <code>^</code>). Reads a <code>string</code> that can be empty, if the next input character does not match the range. The set of characters from <code>c1</code> to <code>c2</code> (inclusively) is denoted by <code>c1-c2</code>. Hence, <code>%[0-9]</code> returns a string representing a decimal number or an empty string if no decimal digit is found; similarly, <code>%[0-9a-f]</code> returns a string of hexadecimal digits. If a closing bracket appears in a range, it must occur as the first character of the range (or just after the <code>^</code> in case of range negation); hence <code>[]]</code> matches a <code>]</code> character and <code>[^]]</code> matches any character that is not <code>]</code>. Use <code>%%</code> and <code>%@</code> to include a <code>%</code> or a <code>@</code> in a range.</li><li><code>r</code>: user-defined reader. Takes the next <code>ri</code> formatted input function and applies it to the scanning buffer <code>ib</code> to read the next argument. The input function <code>ri</code> must therefore have type <code>Scanning.in_channel -&gt; 'a</code> and the argument read has type <code>'a</code>.</li><li><code>{ fmt %}</code>: reads a format string argument. The format string read must have the same type as the format string specification <code>fmt</code>. For instance, <code>&quot;%{ %i %}&quot;</code> reads any format string that can read a value of type <code>int</code>; hence, if <code>s</code> is the string <code>&quot;fmt:\&quot;number is %u\&quot;&quot;</code>, then <code>Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code> succeeds and returns the format string <code>&quot;number is %u&quot;</code>.</li><li><code>( fmt %)</code>: scanning sub-format substitution. Reads a format string <code>rf</code> in the input, then goes on scanning with <code>rf</code> instead of scanning with <code>fmt</code>. The format string <code>rf</code> must have the same type as the format string specification <code>fmt</code> that it replaces. For instance, <code>&quot;%( %i %)&quot;</code> reads any format string that can read a value of type <code>int</code>. The conversion returns the format string read <code>rf</code>, and then a value read using <code>rf</code>. Hence, if <code>s</code> is the string <code>&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then <code>Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to <code>(&quot;%4d&quot;, 1234)</code>. This behaviour is not mere format substitution, since the conversion returns the format string read as additional argument. If you need pure format substitution, use special flag <code>_</code> to discard the extraneous argument: conversion <code>%_( fmt %)</code> reads a format string <code>rf</code> and then behaves the same as format string <code>rf</code>. Hence, if <code>s</code> is the string <code>&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then <code>Scanf.sscanf s &quot;%_(%i%)&quot;</code> is simply equivalent to <code>Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li><li><code>l</code>: returns the number of lines read so far.</li><li><code>n</code>: returns the number of characters read so far.</li><li><code>N</code> or <code>L</code>: returns the number of tokens read so far.</li><li><code>!</code>: matches the end of input condition.</li><li><code>%</code>: matches one <code>%</code> character in the input.</li><li><code>@</code>: matches one <code>@</code> character in the input.</li><li><code>,</code>: does nothing.</li></ul><p>Following the <code>%</code> character that introduces a conversion, there may be the special flag <code>_</code>: the conversion that follows occurs as usual, but the resulting value is discarded. For instance, if <code>f</code> is the function <code>fun i -&gt; i + 1</code>, and <code>s</code> is the string <code>&quot;x = 1&quot;</code>, then <code>Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code>2</code>.</p><p>The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, <code>%6d</code> reads an integer, having at most 6 decimal digits; <code>%4f</code> reads a float with at most 4 characters; and <code>%8[\000-\255]</code> returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).</p><p>Notes:</p><ul><li>as mentioned above, a <code>%s</code> conversion always succeeds, even if there is nothing to read in the input: in this case, it simply returns <code>&quot;&quot;</code>.</li></ul><ul><li>in addition to the relevant digits, <code>'_'</code> characters may appear inside numbers (this is reminiscent to the usual OCaml lexical conventions). If stricter scanning is desired, use the range conversion facility instead of the number conversions.</li></ul><ul><li>the <code>scanf</code> facility is not intended for heavy duty lexical analysis and parsing. If it appears not expressive enough for your needs, several alternative exists: regular expressions (module <a href="../../Str/index.html"><code>Str</code></a>), stream parsers, <code>ocamllex</code>-generated lexers, <code>ocamlyacc</code>-generated parsers.</li></ul><h3 id="indication"><a href="#indication" class="anchor"></a>Scanning indications in format strings</h3><p>Scanning indications appear just after the string conversions <code>%s</code> and <code>%[ range ]</code> to delimit the end of the token. A scanning indication is introduced by a <code>@</code> character, followed by some plain character <code>c</code>. It means that the string token should end just before the next matching <code>c</code> (which is skipped). If no <code>c</code> character is encountered, the string token spreads as much as possible. For instance, <code>&quot;%s@\t&quot;</code> reads a string up to the next tab character or to the end of input. If a <code>@</code> character appears anywhere else in the format string, it is treated as a plain character.</p><p>Note:</p><ul><li>As usual in format strings, <code>%</code> and <code>@</code> characters must be escaped using <code>%%</code> and <code>%@</code>; this rule still holds within range specifications and scanning indications. For instance, format <code>&quot;%s@%%&quot;</code> reads a string up to the next <code>%</code> character, and format <code>&quot;%s@%@&quot;</code> reads a string up to the next <code>@</code>.</li><li>The scanning indications introduce slight differences in the syntax of <a href="#"><code>Scanf</code></a> format strings, compared to those used for the <a href="../Printf/index.html"><code>Printf</code></a> module. However, the scanning indications are similar to those used in the <a href="../Format/index.html"><code>Format</code></a> module; hence, when producing formatted text to be scanned by <a href="#val-bscanf"><code>Scanf.bscanf</code></a>, it is wise to use printing functions from the <a href="../Format/index.html"><code>Format</code></a> module (or, if you need to use functions from <a href="../Printf/index.html"><code>Printf</code></a>, banish or carefully double check the format strings that contain <code>'@'</code> characters).</li></ul><h3 id="exceptions-during-scanning"><a href="#exceptions-during-scanning" class="anchor"></a>Exceptions during scanning</h3><p>Scanners may raise the following exceptions when the input cannot be read according to the format string:</p><ul><li>Raise <a href="#exception-Scan_failure"><code>Scanf.Scan_failure</code></a> if the input does not match the format.</li></ul><ul><li>Raise <code>Failure</code> if a conversion to a number is not possible.</li></ul><ul><li>Raise <code>End_of_file</code> if the end of input is encountered while some more characters are needed to read the current conversion specification.</li></ul><ul><li>Raise <code>Invalid_argument</code> if the format string is invalid.</li></ul><p>Note:</p><ul><li>as a consequence, scanning a <code>%s</code> conversion never raises exception <code>End_of_file</code>: if the end of input is reached the conversion succeeds and simply returns the characters read so far, or <code>&quot;&quot;</code> if none were ever read.</li></ul><h2 id="specialised-formatted-input-functions"><a href="#specialised-formatted-input-functions" class="anchor"></a>Specialised formatted input functions</h2><div class="odoc-spec"><div class="spec value anchored" id="val-sscanf"><a href="#val-sscanf" class="anchor"></a><code><span><span class="keyword">val</span> sscanf : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-bscanf"><code>Scanf.bscanf</code></a>, but reads from the given string.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sscanf_opt"><a href="#val-sscanf_opt" class="anchor"></a><code><span><span class="keyword">val</span> sscanf_opt : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner_opt">scanner_opt</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-sscanf"><code>Scanf.sscanf</code></a>, but returns <code>None</code> in case of scanning failure.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scanf"><a href="#val-scanf" class="anchor"></a><code><span><span class="keyword">val</span> scanf : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-bscanf"><code>Scanf.bscanf</code></a>, but reads from the predefined formatted input channel <a href="Scanning/index.html#val-stdin"><code>Scanf.Scanning.stdin</code></a> that is connected to <a href="../index.html#val-stdin"><code>Stdlib.stdin</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scanf_opt"><a href="#val-scanf_opt" class="anchor"></a><code><span><span class="keyword">val</span> scanf_opt : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner_opt">scanner_opt</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-scanf"><code>Scanf.scanf</code></a>, but returns <code>None</code> in case of scanning failure.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-kscanf"><a href="#val-kscanf" class="anchor"></a><code><span><span class="keyword">val</span> kscanf : 
  <span><a href="Scanning/index.html#type-in_channel">Scanning.in_channel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="Scanning/index.html#type-in_channel">Scanning.in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-bscanf"><code>Scanf.bscanf</code></a>, but takes an additional function argument <code>ef</code> that is called in case of error: if the scanning process or some conversion fails, the scanning function aborts and calls the error handling function <code>ef</code> with the formatted input channel and the exception that aborted the scanning process as arguments.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ksscanf"><a href="#val-ksscanf" class="anchor"></a><code><span><span class="keyword">val</span> ksscanf : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="Scanning/index.html#type-in_channel">Scanning.in_channel</a> <span class="arrow">&#45;&gt;</span></span> <span>exn <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'d</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span> <a href="#type-scanner">scanner</a></span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-kscanf"><code>Scanf.kscanf</code></a> but reads from the given string.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.02</li></ul></div></div><h2 id="reading-format-strings-from-input"><a href="#reading-format-strings-from-input" class="anchor"></a>Reading format strings from input</h2><div class="odoc-spec"><div class="spec value anchored" id="val-bscanf_format"><a href="#val-bscanf_format" class="anchor"></a><code><span><span class="keyword">val</span> bscanf_format : 
  <span><a href="Scanning/index.html#type-in_channel">Scanning.in_channel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'g</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'g</span></span></code></div><div class="spec-doc"><p><code>bscanf_format ic fmt f</code> reads a format string token from the formatted input channel <code>ic</code>, according to the given format string <code>fmt</code>, and applies <code>f</code> to the resulting format string value.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Scan_failure"><code>Scan_failure</code></a> <p>if the format string value read does not have the same type as <code>fmt</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.09</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-sscanf_format"><a href="#val-sscanf_format" class="anchor"></a><code><span><span class="keyword">val</span> sscanf_format : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'g</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'g</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-bscanf_format"><code>Scanf.bscanf_format</code></a>, but reads from the given string.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.09</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-format_from_string"><a href="#val-format_from_string" class="anchor"></a><code><span><span class="keyword">val</span> format_from_string : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../index.html#type-format6">format6</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>, <span class="type-var">'f</span>)</span> <a href="../index.html#type-format6">format6</a></span></span></code></div><div class="spec-doc"><p><code>format_from_string s fmt</code> converts a string argument to a format string, according to the given format string <code>fmt</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Scan_failure"><code>Scan_failure</code></a> <p>if <code>s</code>, considered as a format string, does not have the same type as <code>fmt</code>.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 3.10</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unescaped"><a href="#val-unescaped" class="anchor"></a><code><span><span class="keyword">val</span> unescaped : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p><code>unescaped s</code> return a copy of <code>s</code> with escape sequences (according to the lexical conventions of OCaml) replaced by their corresponding special characters. More precisely, <code>Scanf.unescaped</code> has the following property: for all string <code>s</code>, <code>Scanf.unescaped (String.escaped s) = s</code>.</p><p>Always return a copy of the argument, even if there is no escape sequence in the argument.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <a href="#exception-Scan_failure"><code>Scan_failure</code></a> <p>if <code>s</code> is not properly escaped (i.e. <code>s</code> has invalid escape sequences or special characters that are not properly escaped). For instance, <code>Scanf.unescaped &quot;\&quot;&quot;</code> will fail.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 4.00</li></ul></div></div></div></body></html>
