<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Diffing (ocaml.Diffing)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ocaml</a> &#x00BB; Diffing</nav><header class="odoc-preamble"><h1>Module <code><span>Diffing</span></code></h1><p>Parametric diffing</p><p>This module implements diffing over lists of arbitrary content. It is parameterized by</p><ul><li>The content of the two lists</li><li>The equality witness when an element is kept</li><li>The diffing witness when an element is changed</li></ul><p>Diffing is extended to maintain state depending on the computed changes while walking through the two lists.</p><p>The underlying algorithm is a modified Wagner-Fischer algorithm (see &lt;https://en.wikipedia.org/wiki/Wagner%E2%80%93Fischer_algorithm&gt;).</p><p>We provide the following guarantee: Given two lists <code>l</code> and <code>r</code>, if different patches result in different states, we say that the state diverges.</p><ul><li>We always return the optimal patch on prefixes of <code>l</code> and <code>r</code> on which state does not diverge.</li><li>Otherwise, we return a correct but non-optimal patch where subpatches with no divergent states are optimal for the given initial state.</li></ul><p>More precisely, the optimality of Wagner-Fischer depends on the property that the edit-distance between a k-prefix of the left input and a l-prefix of the right input d(k,l) satisfies</p><p>d(k,l) = min ( del_cost + d(k-1,l), insert_cost + d(k,l-1), change_cost + d(k-1,l-1) )</p><p>Under this hypothesis, it is optimal to choose greedily the state of the minimal patch transforming the left k-prefix into the right l-prefix as a representative of the states of all possible patches transforming the left k-prefix into the right l-prefix.</p><p>If this property is not satisfied, we can still choose greedily a representative state. However, the computed patch is no more guaranteed to be globally optimal. Nevertheless, it is still a correct patch, which is even optimal among all explored patches.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Defs"><a href="#module-type-Defs" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Defs/index.html">Defs</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The core types of a diffing implementation</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-change_kind"><a href="#type-change_kind" class="anchor"></a><code><span><span class="keyword">type</span> change_kind</span><span> = </span></code><ol><li id="type-change_kind.Deletion" class="def variant constructor anchored"><a href="#type-change_kind.Deletion" class="anchor"></a><code><span>| </span><span><span class="constructor">Deletion</span></span></code></li><li id="type-change_kind.Insertion" class="def variant constructor anchored"><a href="#type-change_kind.Insertion" class="anchor"></a><code><span>| </span><span><span class="constructor">Insertion</span></span></code></li><li id="type-change_kind.Modification" class="def variant constructor anchored"><a href="#type-change_kind.Modification" class="anchor"></a><code><span>| </span><span><span class="constructor">Modification</span></span></code></li><li id="type-change_kind.Preservation" class="def variant constructor anchored"><a href="#type-change_kind.Preservation" class="anchor"></a><code><span>| </span><span><span class="constructor">Preservation</span></span></code></li></ol></div><div class="spec-doc"><p>The kind of changes which is used to share printing and styling across implementation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefix"><a href="#val-prefix" class="anchor"></a><code><span><span class="keyword">val</span> prefix : <span><span>(int * <a href="#type-change_kind">change_kind</a>)</span> <a href="../Format_doc/index.html#type-printer">Format_doc.printer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-style"><a href="#val-style" class="anchor"></a><code><span><span class="keyword">val</span> style : <span><a href="#type-change_kind">change_kind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Misc/Style/index.html#type-style">Misc.Style.style</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-change"><a href="#type-change" class="anchor"></a><code><span><span class="keyword">type</span> <span>('left, 'right, 'eq, 'diff) change</span></span><span> = </span></code><ol><li id="type-change.Delete" class="def variant constructor anchored"><a href="#type-change.Delete" class="anchor"></a><code><span>| </span><span><span class="constructor">Delete</span> <span class="keyword">of</span> <span class="type-var">'left</span></span></code></li><li id="type-change.Insert" class="def variant constructor anchored"><a href="#type-change.Insert" class="anchor"></a><code><span>| </span><span><span class="constructor">Insert</span> <span class="keyword">of</span> <span class="type-var">'right</span></span></code></li><li id="type-change.Keep" class="def variant constructor anchored"><a href="#type-change.Keep" class="anchor"></a><code><span>| </span><span><span class="constructor">Keep</span> <span class="keyword">of</span> <span class="type-var">'left</span> * <span class="type-var">'right</span> * <span class="type-var">'eq</span></span></code></li><li id="type-change.Change" class="def variant constructor anchored"><a href="#type-change.Change" class="anchor"></a><code><span>| </span><span><span class="constructor">Change</span> <span class="keyword">of</span> <span class="type-var">'left</span> * <span class="type-var">'right</span> * <span class="type-var">'diff</span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-classify"><a href="#val-classify" class="anchor"></a><code><span><span class="keyword">val</span> classify : <span><span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="#type-change">change</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-change_kind">change_kind</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Define"><a href="#module-Define" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Define/index.html">Define</a></span><span> (<a href="Define/argument-1-D/index.html">D</a> : <a href="module-type-Defs/index.html">Defs</a>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><code>Define(Defs)</code> creates the diffing types from the types defined in <code>Defs</code> and the functors that need to be instantatied with the diffing algorithm parameters</p></div></div></div></body></html>
