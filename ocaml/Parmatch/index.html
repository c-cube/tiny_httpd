<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Parmatch (ocaml.Parmatch)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">ocaml</a> &#x00BB; Parmatch</nav><header class="odoc-preamble"><h1>Module <code><span>Parmatch</span></code></h1><p>Detection of partial matches and unused match cases.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-parmatch_case"><a href="#type-parmatch_case" class="anchor"></a><code><span><span class="keyword">type</span> <span>'pattern parmatch_case</span></span><span> = </span><span>{</span></code><ol><li id="type-parmatch_case.pattern" class="def record field anchored"><a href="#type-parmatch_case.pattern" class="anchor"></a><code><span>pattern : <span class="type-var">'pattern</span>;</span></code></li><li id="type-parmatch_case.has_guard" class="def record field anchored"><a href="#type-parmatch_case.has_guard" class="anchor"></a><code><span>has_guard : bool;</span></code></li><li id="type-parmatch_case.needs_refute" class="def record field anchored"><a href="#type-parmatch_case.needs_refute" class="anchor"></a><code><span>needs_refute : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>true if the program text claims the case is unreachable, a la <code>function _ -&gt; .</code></p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Most checks in this file need not access all information about a case, and just need a few pieces of information. <code>parmatch_case</code> is those few pieces of information.</p></div></div><div class="odoc-spec"><div class="spec type subst anchored" id="type-typed_case"><a href="#type-typed_case" class="anchor"></a><code><span><span class="keyword">type</span> <span>'category typed_case</span></span><span> := <span><span><span class="type-var">'category</span> <a href="../Typedtree/index.html#type-general_pattern">Typedtree.general_pattern</a></span> <a href="#type-parmatch_case">parmatch_case</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typed_case"><a href="#val-typed_case" class="anchor"></a><code><span><span class="keyword">val</span> typed_case : <span><span><span class="type-var">'category</span> <a href="../Typedtree/index.html#type-case">Typedtree.case</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'category</span> <a href="#type-typed_case">typed_case</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-untyped_case"><a href="#val-untyped_case" class="anchor"></a><code><span><span class="keyword">val</span> untyped_case : <span><a href="../Parsetree/index.html#type-case">Parsetree.case</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Parsetree/index.html#type-pattern">Parsetree.pattern</a> <a href="#type-parmatch_case">parmatch_case</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-const_compare"><a href="#val-const_compare" class="anchor"></a><code><span><span class="keyword">val</span> const_compare : <span><a href="../Asttypes/index.html#type-constant">Asttypes.constant</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Asttypes/index.html#type-constant">Asttypes.constant</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>const_compare c1 c2</code> compares the actual values represented by <code>c1</code> and <code>c2</code>, while simply using <code>Stdlib.compare</code> would compare the representations.</p><p>cf. MPR#5758</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-le_pat"><a href="#val-le_pat" class="anchor"></a><code><span><span class="keyword">val</span> le_pat : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>le_pat p q</code> means: forall V, V matches q implies V matches p</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-le_pats"><a href="#val-le_pats" class="anchor"></a><code><span><span class="keyword">val</span> le_pats : <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>le_pats (p1 .. pm) (q1 .. qn)</code> means: forall i &lt;= m, <code>le_pat pi qi</code></p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Compat"><a href="#module-Compat" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Compat/index.html">Compat</a></span><span> (<a href="Compat/argument-1-_/index.html">_</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Exported compatibility functor, abstracted over constructor equality</p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Empty"><a href="#exception-Empty" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Empty</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lub"><a href="#val-lub" class="anchor"></a><code><span><span class="keyword">val</span> lub : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></span></code></div><div class="spec-doc"><p><code>lub p q</code> is a pattern that matches all values matched by <code>p</code> and <code>q</code>. May raise <code>Empty</code>, when <code>p</code> and <code>q</code> are not compatible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lubs"><a href="#val-lubs" class="anchor"></a><code><span><span class="keyword">val</span> lubs : 
  <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div><div class="spec-doc"><p><code>lubs [p1; ...; pn] [q1; ...; qk]</code>, where <code>n &lt; k</code>, is <code>[lub p1 q1; ...; lub pk qk]</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_mins"><a href="#val-get_mins" class="anchor"></a><code><span><span class="keyword">val</span> get_mins : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_args"><a href="#val-set_args" class="anchor"></a><code><span><span class="keyword">val</span> set_args : 
  <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div><div class="spec-doc"><p>This function recombines one pattern and its arguments: For instance: (_,_)::p1::p2::rem -&gt; (p1, p2)::rem</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pat_of_constr"><a href="#val-pat_of_constr" class="anchor"></a><code><span><span class="keyword">val</span> pat_of_constr : 
  <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-complete_constrs"><a href="#val-complete_constrs" class="anchor"></a><code><span><span class="keyword">val</span> complete_constrs : 
  <span><span><a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> <a href="../Typedtree/index.html#type-pattern_data">Typedtree.pattern_data</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Types/index.html#type-constructor_description">Types.constructor_description</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pats_of_type"><a href="#val-pats_of_type" class="anchor"></a><code><span><span class="keyword">val</span> pats_of_type : <span><a href="../Env/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Types/index.html#type-type_expr">Types.type_expr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span></span></code></div><div class="spec-doc"><p><code>pats_of_type</code> builds a list of patterns from a given expected type, for explosion of wildcard patterns in Typecore.type_pat.</p><p>There are four interesting cases:</p><ul><li>the type is empty ()</li><li>no further explosion is necessary (<code>Pat_any</code>)</li><li>a single pattern is generated, from a record or tuple type or a single-variant type (<code>tp</code>)</li><li>a list of patterns, in the case that all branches are GADT constructors (<code>tp1; ..; tpn</code>).</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pressure_variants"><a href="#val-pressure_variants" class="anchor"></a><code><span><span class="keyword">val</span> pressure_variants : <span><a href="../Env/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pressure_variants_in_computation_pattern"><a href="#val-pressure_variants_in_computation_pattern" class="anchor"></a><code><span><span class="keyword">val</span> pressure_variants_in_computation_pattern : 
  <span><a href="../Env/index.html#type-t">Env.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Typedtree/index.html#type-computation">Typedtree.computation</a> <a href="../Typedtree/index.html#type-general_pattern">Typedtree.general_pattern</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_partial"><a href="#val-check_partial" class="anchor"></a><code><span><span class="keyword">val</span> check_partial : 
  <span><span>(<span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Location/index.html#type-t">Location.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Typedtree/index.html#type-value">Typedtree.value</a> <a href="#type-typed_case">typed_case</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Typedtree/index.html#type-partial">Typedtree.partial</a></span></code></div><div class="spec-doc"><p><code>check_partial pred loc caselist</code> and <code>check_unused refute pred caselist</code> are called with a function <code>pred</code> which will be given counter-example candidates: they may be partially ill-typed, and have to be type-checked to extract a valid counter-example. <code>pred</code> returns a valid counter-example or <code>None</code>. <code>refute</code> indicates that <code>check_unused</code> was called on a refutation clause.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_unused"><a href="#val-check_unused" class="anchor"></a><code><span><span class="keyword">val</span> check_unused : 
  <span><span>(<span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Typedtree/index.html#type-value">Typedtree.value</a> <a href="#type-typed_case">typed_case</a></span> list</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-irrefutable"><a href="#val-irrefutable" class="anchor"></a><code><span><span class="keyword">val</span> irrefutable : <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inactive"><a href="#val-inactive" class="anchor"></a><code><span><span class="keyword">val</span> inactive : <span><span class="label">partial</span>:<a href="../Typedtree/index.html#type-partial">Typedtree.partial</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typedtree/index.html#type-pattern">Typedtree.pattern</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>An inactive pattern is a pattern, matching against which can be duplicated, erased or delayed without change in observable behavior of the program. Patterns containing (lazy _) subpatterns or reads of mutable fields are active.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check_ambiguous_bindings"><a href="#val-check_ambiguous_bindings" class="anchor"></a><code><span><span class="keyword">val</span> check_ambiguous_bindings : <span><span><span><a href="../Typedtree/index.html#type-value">Typedtree.value</a> <a href="../Typedtree/index.html#type-case">Typedtree.case</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-some_private_tag"><a href="#val-some_private_tag" class="anchor"></a><code><span><span class="keyword">val</span> some_private_tag : <a href="../Asttypes/index.html#type-label">Asttypes.label</a></span></code></div></div></div></body></html>
